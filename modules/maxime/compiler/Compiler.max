import maxime.List
import maxime.Map
import maxime.io.File

class Compiler
  Compiler
  compile(sources: List[File], target: File, options: Map[String, Any]) â†’ Unit =
    def toString(s:Printable) -> String = s.toString()
    
    ("Compiling " + sources.map(toString).join(", ") + " to " + target).println()
    
    class CompilationUnit
      CompilationUnit(path:String, maxFiles:List[String], jsFiles:List[String])
    
    def mkCompilationUnit(path:String) -> CompilationUnit =
      CompilationUnit(path, findFiles(path, regexp("\.max$")), findFiles(path, regexp("\.js$")))
    
    val compilationUnits = sources.map(mkCompilationUnit)
    ("Compilation units: " + compilationUnits.map(toString)).println()
    
    def compileUnit(unit:CompilationUnit) -> String =
    
      class Source
        Source(code:String, file:String)

      def readSource(file:String) -> Source =
        Source(readFile(unit.path + "/" + file), file)

      def parse(source:Source) -> Source = source
      def generate(source:Source) -> Source = source

      def compileSource(source:Source) -> String =
        val moduleName = source.file.replace("\/g", ".").replace("\.max$g", "")
        ("Compiling module " + moduleName).println()
        val ast = parse(source)
        generate(ast)
    
      def getCode(s:Source) -> String = s.code

      val jsSources = unit.jsFiles.map(readSource).map(getCode)
      val maxSources = unit.maxFiles.map(readSource)
      val maxTargets = maxSources.map(compileSource)
      (jsSources ++ maxTargets).join("
")
    
    val codes = compilationUnits.map(compileUnit)
    val code = codes.join("\n")
    val runtimeLib = readFile("runtime/Maxime.js")
    writeFile(target, prop(options, "before") + runtimeLib + code + prop(options, "after"))
    code
